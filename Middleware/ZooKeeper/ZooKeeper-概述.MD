ZooKeeper 
-----------------
协调分布式系统是一个动物园。
ZooKeeper是一种针对分布式应用程序的高性能协调服务。


### 设计目标
#### 足够简单
ZooKeeper允许分布式进程通过一个共享的层次化名称空间相互协调，这个名称空间的组织方式类似于标准文件系统。
名称空间由数据寄存器组成——用ZooKeeper的说法，称为znode——这些寄存器类似于文件和目录。
与为存储而设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟数。

ZooKeeper的实现重视高性能、高可用性和严格有序的访问。
ZooKeeper的性能方面意味着它可以在大型分布式系统中使用。
可靠性方面使它不至于成为单点故障。
严格的排序意味着复杂的同步原语可以在客户端实现。

#### 可复制（集群拓展，高可用）
像它所协调的分布式进程一样，ZooKeeper本身也可以在称为集合的一组主机上进行复制。

组成ZooKeeper服务的服务器必须相互了解。
它们维护状态的内存映像，以及持久存储中的事务日志和快照。
只要大多数服务器可用，ZooKeeper服务就可以使用。

客户端连接到单个ZooKeeper服务器。
客户机维护一个TCP连接，通过它发送请求、获取响应、获取监视事件和发送心跳。
如果到服务器的TCP连接中断，客户端将连接到其他服务器。

 ![zkservice](https://zookeeper.apache.org/doc/current/images/zkservice.jpg)

#### 有序（事务）
ZooKeeper用一个反映所有ZooKeeper事务顺序的数字标记每个更新。
后续操作可以使用该命令来实现更高级别的抽象，例如同步原语。
#### 快速（高性能）
在“读取为主”的工作负载中，它特别快。 
ZooKeeper应用程序可在数千台计算机上运行，并且在读取比写入更常见的情况下以10：1的比率运行时效果最佳。

### 数据模型和分层命名空间
ZooKeeper提供的名称空间与标准文件系统的名称空间非常相似。
名称是由斜杠（/）分隔的一系列路径元素。 
ZooKeeper命名空间中的每个节点都由路径标识。

 ![zknamespace](https://zookeeper.apache.org/doc/current/images/zknamespace.jpg)

### 节点和临时节点
与标准文件系统不同，ZooKeeper命名空间中的每个节点都可以有与其关联的数据以及子节点。
这就像有一个文件系统，允许一个文件也成为一个目录(znode 既是文件又是文件夹)。
（ZooKeeper被设计用来存储协调数据：状态信息、配置、位置信息等，因此存储在每个节点上的数据通常很小，在千字节范围内。）
我们使用znode这个术语来清楚地说明我们所说的ZooKeeper数据节点。

znode维护一个stat结构，其中包含数据更改、ACL更改和时间戳的版本号，以允许缓存验证和协调更新。
每次znode的数据更改时，版本号都会增加。
例如，每当客户机检索数据时，它也会接收数据的版本。

存储在命名空间中每个znode上的数据是原子读写的。
Reads获取与znode相关的所有数据字节，write替换所有数据。
每个节点都有一个访问控制列表（ACL），限制谁可以做什么。

#### 临时节点
ZooKeeper也有临时节点的概念。
只要创建znode的会话处于活动状态，这些临时znode就存在。
当会话结束时，临时znode自动被删除。

### 条件更新和监视
ZooKeeper支持监视的概念。客户可以在znode上设置监视。
当znode发生变化时，监视将被触发并移除。
当一个监视被触发时，客户端收到一个数据包，说znode已经改变了。
如果客户端和ZooKeeper服务器之一之间的连接断开，客户端将收到本地通知。

**3.6.0中的新增功能：** 
客户端还可以在znode上设置永久的，递归的监视，这些监视在触发时不会被删除，并且会以递归方式触发已注册znode以及所有子znode的更改。

### 保证
ZooKeeper 非常快且简单。不过，由于它的目标是作为构建更复杂服务（如同步）的基础，因此它提供了一组保证。
- `有序性` 来自客户端的更新将按发送顺序应用。
- `原子性` 更新结果要么全部成功要么全部失败。
- `统一性` 单一系统映像，无论连接到哪个服务器，客户端都将看到相同的服务视图。
- `可靠性` 一旦应用了更新，它将从那时起一直存在，直到客户端覆盖更新。
- `及时性` 保证系统的客户端视图在一定的时间范围内是最新的。

### 简洁API
ZooKeeper的设计目标之一是提供一个非常简单的编程接口。
它仅支持以下操作：
 - `create` 创建节点
 - `delete` 删除节点
 - `exists` 节点是否存在
 - `get data` 从节点读取数据
 - `set data` 往节点写入数据
 - `get children` 读取子节点列表
 - `sync` 同步，等待数据传播
### 实现
每个ZooKeeper服务器都为客户端提供服务。

ZooKeeper使用自定义的原子消息传递协议。由于消息传递层是原子的，ZooKeeper可以保证本地副本永远不会分离。
当leader接收到一个写请求时，它会计算应用写请求时系统的状态，并将其转换为捕获这个新状态的事务。
 ![zkcomponents](https://zookeeper.apache.org/doc/current/images/zkcomponents.jpg)

### 使用
ZooKeeper的编程接口刻意简单。
但是，有了它，您可以实现更高阶的操作，例如同步原语，组成员身份，所有权等。

### 性能
ZooKeeper被设计为具有高性能。

### 可靠
 1. 首先，如果跟随者失败并快速恢复，那么ZooKeeper能够在失败的情况下保持高吞吐量。
 2. 但也许更重要的是，领导人选举算法允许系统恢复足够快，以防止吞吐量大幅下降。根据我们的观察，ZooKeeper只需不到200秒就可以选出一位新的领导人。
 3. 第三，随着跟随者的恢复，一旦他们开始处理请求，ZooKeeper就能够再次提高吞吐量。

### ZooKeeper项目
呼吁所有用户和开发人员加入社区并贡献专业知识。

