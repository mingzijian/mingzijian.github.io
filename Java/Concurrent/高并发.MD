高并发
---------
高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。
### 知识点
#### CPU 缓存
##### 多级缓存

##### 缓存一致性

##### 乱序执行优化
乱序执行（Out-Of-Order Execution）简称OOE。是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术。
#### Java 内存模型
Java内存模型 (Java Memory Model) 简称JMM。JMM定义了程序中各个共享变量的访问规则,即在虚拟机中将变量存储到内存和从内存读取变量这样的底层细节。
##### 主内存,工作内存和线程三者的交互关系
JMM规定了共享变量都存储在主内存中。
每条线程有自己的工作内存, 线程的工作内存保存了主内存的副本拷贝,
对变量的操作在工作内存中进行, 不能直接操作主内存中的变量。
不同线程间无法直接访问对方的工作内存变量,需要通过主内存完成。

##### JMM 操作（原子操作）
- lock （锁定）
	作用于主内存的变量，把一个变量标识为线程独占状态
- unlock （解锁）
	作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- read （读取）
	作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load （载入）
	作用于工作内存的变量，它把read操作从主存中变量放入工作内存中
- use （使用）
	作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作
- assign （赋值）
	作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作
- store （存储）
	作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用
- write（写入）
	作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

**操作规则：**
1，read和load，store和write必须成对出现。即：read之后必须load, write之前也必须先store
2，不允许线程丢弃他最近的assign操作。即：工作变量的数据改变之后，必须告知主存
3，不允许线程将未assign的数据同步到主存
4，新变量在主内存中诞生，不允许工作内存直接use一个未被初始化的变量。
5，一个变量同一时间只能被一个线程lock。多次lock后，必须执行相同次数的unlock才能解锁。即：同一个线程对一个变量加锁后，可以继续加锁，同时在释放锁的时候释放锁次数必须和加锁次数相同。
6，不能对未被lock的变量进行unlock操作。也不能unlock一个被其他线程lock的变量
7，对变量执行lock操作，就会清空工作空间该变量的值，执行引擎使用这个变量之前，需要重新执行load或者assign操作初始化变量的值
8，对一个变量进行unlock操作之前，必须把此变量同步回主存。即：执行store和write操作

##### JMM 重排序

###### 重排序对多线程的影响
flag变量是个标记，用来标识变量a是否已被写入。这里假设有两个线程A和B，A首先执行`writer()`方法，随后B线程接着执行`reader()`方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量`a`的写入？
```java
class ReorderExample {
    int a = 0;
    boolean flag = false;
 
    public void writer() {
        a = 1;                   //1
        flag = true;             //2
    }
 
    Public void reader() {
        if (flag) {              //3
            int i =  a * a;      //4
            ......
        }
    }
}
```
操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；
操作3和操作4存在控制依赖关系，当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算`a*a`，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer `ROB`）的硬件缓存中。当接下来操作3的条件判断为`true`时，就把该计算结果写入变量`i`中。

可以看出，*猜测执行*实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！

在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是`as-if-serial`语义允许对存在控制依赖的操作做重排序的原因）；
但**在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果**。


##### 先行发生原则 （happens-before）
happens-before是JMM定义的2个操作之间的偏序关系：如果操作A先行发生于操作B，则A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。
如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。
**注意**
    两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。

#### 扩容（高可用）

#### 队列

#### 限流/降级/熔断
##### 限流
限制流量
###### 常见限流算法
- 计数器算法 
滑动窗口；有新的请求进来时，时间窗口内请求计数+1；超过阈值时不处理新的请求
- 令牌桶算法 
匀速放入令牌。有新的请求进来时，先取走令牌再处理请求；令牌不足时不处理新的请求
- 漏水桶算法 
匀速流出水；有新的请求进来时，先流入水再处理请求；桶满时不处理新的请求

##### 降级
降低服务的优先级

##### 熔断
当某个目标服务调用慢或者有大量超时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。待目标服务情况好转时再恢复调用。

###### 雪崩效应
一种因服务提供者的不可用导致服务调用者的不可用,并将不可用逐渐放大的过程

#### 线程安全
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类时线程安全的。
##### 并发容器 J.U.C (java.util.concurrent)

| 非线程安全 | 线程安全                 |
| --------- | ---------------------- |
| ArratList | CopyOnWriteArraySet    |
| HashSet   | CopyOnWriteArraySet    |
| TreeSet   | ConcurrentSkipListSet  |
| HashMap   | ConcurrentHashMap      |
| TreeMap   | ConcurrentSkipListMap  |

### 最佳实践
- 使用本地变量
- 使用不可变类
- 最小化锁的作用域范围：S=1/(1-a+a/n)
- 使用线程池的Executor，而不是直接new Thread执行
- 宁可使用同步也不要使用线程的wait和notify
- 使用BlockingQueue实现生产-消费模式
- 使用并发集合而不是加了锁的同步集合
- 使用Semaphore创建有界的访问
- 宁可使用同步代码块，也不使用同步方法
- 避免使用静态变量
- 多线程wait时使用while而不是if

### 参考

- [Java内存模型总结 --AlphaWang](https://blog.csdn.net/vking_wang/article/details/8574376)
- [Java内存模型一（基础）--程晓明](https://www.infoq.cn/article/java-memory-model-1)
- [Java内存模型二（重排序）--程晓明](https://www.infoq.cn/article/java-memory-model-2)
- [Java内存模型三（顺序一致性）--程晓明](https://www.infoq.cn/article/java-memory-model-3)
- [Java内存模型四（volatile）--程晓明](https://www.infoq.cn/article/java-memory-model-4)
- [Java内存模型五（锁）--程晓明](https://www.infoq.cn/article/java-memory-model-5)
- [Java内存模型六（final）--程晓明](https://www.infoq.cn/article/java-memory-model-6)
- [Java内存模型七（总结）--程晓明](https://www.infoq.cn/article/java-memory-model-7)

