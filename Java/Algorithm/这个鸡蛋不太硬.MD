#### 问题：
两个软硬程度一样但未知的鸡蛋，它们有可能都在一楼就摔碎，也可能从一百层楼摔下来没事。
有座100层的建筑，要你用这两个鸡蛋确定哪一层是鸡蛋可以安全落下的最高位置。可以摔碎两个鸡蛋。
最少需要几次测试，才能得到摔碎鸡蛋的楼层？方案如何？

<br> x + (x-1) + (x-2) + (x-3) + 1 >= 100
<br> x(x+1)/2 >= 100
<br> x^2 + x + (-200) >= 0
<br>一元二次方程有最小正整数解：14

<br>随机1000次结果如下：
 - avgTimes:10
 - maxTimes:14
 - minTimes:3

```java 

public class MainTest {
    
    
    public static void main(String[] args) {


        int tryTimes = 1000;
        for (int i = 0; i < tryTimes; i++) {
            new MainTest().testThrowEgg();
        }

        //System.out.println("totalTimes:"+totalTimes);
        System.out.println("avgTimes:" + totalTimes / tryTimes);
        System.out.println("maxTimes:" + maxTimes);
        System.out.println("minTimes:" + minTimes);

    }

    private static int getBestSolution(int a, int b, int c) {
        // a*x^2 + b* + c = 0
        double d = b * b - 4 * a * c;
        //System.out.println(d);
        if (d < 0) {
            //System.out.println("方程无解");
            return 0;
        } else if (d == 0) {
            //System.out.println("方程有一个解:" + -b / (2 * a));
            return -b / (2 * a);
        } else {
            double x1 = (-b + Math.sqrt(d)) / (2 * a);
            double x2 = (-b - Math.sqrt(d)) / (2 * a);
            //System.out.println("方程有两个解：" + (-b + Math.sqrt(d)) / (2 * a) + " 和 " + (-b - Math.sqrt(d)) / (2 * a));
            if (x1 > x2 && x2 < 0) {
                return BigDecimal.valueOf(x1).setScale(0, RoundingMode.UP).intValue();
            } else {
                return BigDecimal.valueOf(x2).setScale(0, RoundingMode.UP).intValue();
            }
        }

    }

    private static int totalTimes = 0;
    private static int maxTimes = 0;
    private static int minTimes = 0;

    int eggNum;//鸡蛋数量
    int maxFloorIndex;//最高楼层号
    int minFloorIndex;//最低楼层号
    int currFloorIndex;//当前楼层号
    int safeFloorIndex;//安全楼层号
    int tempSafeFloorIndex;
    int tempDangerFloorIndex;
    int throwEggTimes;// 扔鸡蛋次数
    int upNumByOnTimes;

    private void initEggAndFloor() {
        eggNum = 2;//鸡蛋数量
        maxFloorIndex = 100;//最高楼层号
        minFloorIndex = 1;//最低楼层号
        currFloorIndex = 1;//当前楼层号
        safeFloorIndex = 1;//安全楼层号
        tempSafeFloorIndex = 0;
        tempDangerFloorIndex = 0;
        throwEggTimes = 0;// 扔鸡蛋次数

    }


    private void randomSafeFloorIndex() {
        safeFloorIndex = RandomUtil.randomInt(minFloorIndex, maxFloorIndex + 1);
        System.out.println("randomSafeFloorIndex:" + safeFloorIndex);
    }

    /**
     * 测试扔鸡蛋
     */
    private void testThrowEgg() {
        initEggAndFloor();
        randomSafeFloorIndex();//随机安全楼层号
        //safeFloorIndex = 77;

        //x(x+1)/2>=100  --> 1*x^2 + 1*x - 200 =0
        // a=1 , b=1 , c=-200
        // c = 剩余楼层数 * -2

        int c = (maxFloorIndex - tempSafeFloorIndex) * -2;
        upNumByOnTimes = getBestSolution(1, 1, c);
        System.out.println("===>upNumByOnTimes:" + upNumByOnTimes);
        upFloorThenThrowEgg(upNumByOnTimes);
    }

    private void throwEgg() {

        throwEggTimes++;// 扔了一次鸡蛋
        if (isThrowSafe()) {
            if (isBestFloorIndex()) {
                System.out.println("=====> throwEggTimes:" + throwEggTimes);
                System.out.println("===> safeFloorIndex:" + currFloorIndex);
                totalTimes += throwEggTimes;
                if (throwEggTimes > maxTimes) {
                    maxTimes = throwEggTimes;
                }
                if (throwEggTimes < minTimes || minTimes == 0) {
                    minTimes = throwEggTimes;
                }
                return;
            }
            tempSafeFloorIndex = currFloorIndex;

            if (currFloorIndex < tempDangerFloorIndex && tempDangerFloorIndex > 0) {
                upFloorThenThrowEgg(1);
            } else {
                //upNumByOnTimes= maxFloorIndex-tempSafeFloorIndex;
                int c = (maxFloorIndex - tempSafeFloorIndex) * -2;
                upNumByOnTimes = getBestSolution(1, 1, c);
                //System.out.println("===>upNumByOnTimes:" + upNumByOnTimes);
                upFloorThenThrowEgg(upNumByOnTimes);
            }

        } else {
            if (currFloorIndex - tempSafeFloorIndex <= 1) {
                System.out.println("=====> throwEggTimes:" + throwEggTimes);
                System.out.println("===> safeFloorIndex:" + tempSafeFloorIndex);
                totalTimes += throwEggTimes;
                if (throwEggTimes > maxTimes) {
                    maxTimes = throwEggTimes;
                }
                if (throwEggTimes < minTimes || minTimes == 0) {
                    minTimes = throwEggTimes;
                }
                return;
            }
            tempDangerFloorIndex = currFloorIndex;
            eggNum--;// 碎了一个鸡蛋
            System.out.println("===> 剩余鸡蛋：" + eggNum);
            if (eggNum <= 0) {
                System.out.println("鸡蛋碎完了");
                return;
            }
            upFloorThenThrowEgg(1-upNumByOnTimes);
        }

    }

    // 往上爬楼
    private void upFloorThenThrowEgg(int upFloorNum) {
        // 爬楼越界修正
        if (currFloorIndex + upFloorNum > maxFloorIndex) {
            currFloorIndex = maxFloorIndex;//最高只能爬到顶楼
            return;
        }
        currFloorIndex += upFloorNum;
        if (currFloorIndex < minFloorIndex || currFloorIndex > maxFloorIndex) {
            System.out.println("爬楼越界 upFloorNum:" + upFloorNum + "\t currFloorIndex:" + currFloorIndex);
            throw new IllegalArgumentException("爬楼越界");
        }
        System.out.println("往"+((upFloorNum>0)?"上":"下")+"爬 "+Math.abs(upFloorNum)+" 层，到达 "+currFloorIndex+" 层");

        /*System.out.println("currFloorIndex:" + currFloorIndex
                + "\t upFloorNum：" + upFloorNum
                + "\t tempSafeFloorIndex：" + tempSafeFloorIndex
                + "\t tempDangerFloorIndex：" + tempDangerFloorIndex
        );*/
        throwEgg();
    }

    private boolean isBestFloorIndex() {

        return (tempDangerFloorIndex - tempSafeFloorIndex <= 1 && tempDangerFloorIndex > 0 && tempSafeFloorIndex > 0)
                || tempSafeFloorIndex == maxFloorIndex
                || currFloorIndex == maxFloorIndex
                || tempDangerFloorIndex-currFloorIndex==1;
    }

    private boolean isThrowSafe() {
        return currFloorIndex <= safeFloorIndex;
    }

}    
```