
a

Spring Core Technologies
----------------------------------------

## Spring 核心技术

 - IoC 容器 （The IoC Container）
 - 资源 （Resources）
 - 验证，数据绑定和类型转换 （Validation, Data Binding, and Type Conversion）
 - Spring表达式语言（SpEL）
 - Spring面向切面编程 （Aspect Oriented Programming with Spring）
 - Spring AOP APIs
 - Null-safety
 - 数据缓冲区和编解码器 （Data Buffers and Codecs）
 - 附录 （Appendix）

### 1. IoC 容器 （The IoC Container）
	介绍Spring的IoC容器
#### 1.1 IoC容器 和 beans 简介
	本章介绍Spring Framework实现控制反转（IoC）[1]原理。 IoC也被称为依赖注入（DI）。 
	它是一个过程，对象通过构造函数参数，工厂方法的参数或在工厂方法构造或返回后在对象实例上设置的属性来定义它们的依赖关系，即它们使用的其他对象。 
	容器在创建bean时会注入这些依赖关系。 
	这个过程从根本上来说是相反的，因此名为控制反转（IoC），bean本身通过使用类的直接构造或诸如Service Locator模式之类的机制来控制其依赖关系的实例化或位置。
	
	org.springframework.beans和org.springframework.context包是Spring Framework的IoC容器的基础。 
	BeanFactory接口提供了一种能够管理任何类型对象的高级配置机制。 ApplicationContext是BeanFactory的一个子接口。 
	它增加了与Spring的AOP功能更容易的集成; 消息资源处理（用于国际化），事件发布; 以及Web应用程序上下文（如Web应用程序上下文）以用于Web应用程序。
	
	简而言之，BeanFactory提供了配置框架和基本功能，而ApplicationContext添加了更多的企业特定功能。 
	ApplicationContext是BeanFactory的一个完整的超集，在本章中专门用于描述Spring的IoC容器。 
	有关使用BeanFactory而不是ApplicationContext的更多信息，请参阅BeanFactory。
	
	在Spring中，构成应用程序主干和由Spring IoC容器管理的对象称为bean。 
	bean是一个由 Spring IoC 容器去实例化、组装和管理的对象。 
	否则，bean只是应用程序中众多对象中的一个。 Bean和它们之间的依赖关系反映在容器使用的配置元数据中。

#### 1.2 容器概述
	`org.springframework.context.ApplicationContext`接口代表Spring IoC容器，负责实例化、配置和组装bean。
	容器通过读取元数据配置获取有关实例化、配置和组装哪些对象的指令。元数据配置可以使用用XML、Java注释或Java代码表示。
	它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。
	Spring提供了`ApplicationContext`接口的几个实现。
	在独立应用程序中，通常会创建`ClassPathXmlApplicationContext`或`FileSystemXmlApplicationContext`的实例。
	虽然XML是定义元数据配置的传统格式，但是您可以通过提供少量的XML配置来指示容器使用Java注释或代码作为元数据格式，以声明方式启用对这些附加元数据格式的支持。
	在大多数应用程序场景中，不需要显式用户代码来实例化Spring IoC容器的一个或多个实例。例如，在web应用程序场景中，在`web.xml`文件应用程序的文件通常就足够了（请参阅Web应用程序的便捷应用程序上下文实例化）。如果您使用Eclipse的Spring工具（一个Eclipse驱动的开发环境），只需单击几次鼠标或击键，就可以轻松地创建这个样板配置。
	
	下图显示了Spring如何工作的高级视图。应用程序类与配置元数据相结合，这样，在创建和初始化ApplicationContext之后，您就拥有了一个完全配置并可执行的系统或应用程序。

![The Spring IoC container](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/images/container-magic.png "The Spring IoC container.png")

##### 1.2.1 配置元数据
	配置形式:
	- 基于XML(传统形式)
	- 基于注解(Spring 2.5引入了对基于注释的配置元数据的支持。)
	- 基于Java(从Spring 3.0开始，Spring JavaConfig项目提供的许多功能成为核心Spring框架的一部分。)

以下示例显示了基于XML的配置元数据的基本结构：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">
    </bean>

    <bean id="..." class="...">
    </bean>
</beans>
```

##### 1.2.2 实例化容器
	实例化Spring IoC容器很简单。 提供给ApplicationContext构造函数的位置路径实际上是资源字符串，它允许容器从各种外部资源（例如本地文件系统，Java CLASSPATH等等）加载配置元数据。
```java
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
```
以下示例显示服务层对象（services.xml）配置文件：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">
  <!-- services -->
  <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
    <property name="accountDao" ref="accountDao"/>
    <property name="itemDao" ref="itemDao"/>
  </bean>
</beans>
```
以下示例显示数据访问对象daos.xml文件：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="accountDao"
        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
  </bean>

  <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
  </bean>
</beans>
```

##### 1.2.3 使用容器
	ApplicationContext是高级工厂的接口，能够维护不同Bean及其依赖项的注册表。 使用方法`T getBean(String name,Class <T> requiredType)`，可以检索bean的实例。

ApplicationContext使您可以读取bean定义并按如下方式访问它们：
```java
// 创建且配置beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// 检索出配置好的实例
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// 使用配置好的实例
List<String> userList = service.getUsernameList();
```
事实上，你的应用程序代码根本不应该调用`getBean()`方法，因此完全不依赖于Spring API。 例如，Spring与Web框架的集成为各种Web框架组件（如控制器和JSF托管的Bean）提供了依赖注入，允许您通过元数据（例如自动装配注解）声明对特定Bean的依赖关系。

#### 1.3 Bean概述
	Spring IoC容器管理一个或多个bean。 这些bean是使用您提供给容器的配置元数据创建的，例如，以XML 定义的形式。

在容器本身中，这些bean定义表示为`BeanDefinition`对象，其中包含以下元数据（以及其他信息）：
- 包限定的类名称：通常是所定义的bean的实际实现类。

- Bean行为配置元素，它说明bean在容器中的行为（范围，生命周期回调等等）。

- 引用bean为其工作所需的其他bean; 这些引用也称为协作器或依赖关系。

- 在新创建的对象中设置的其他配置设置，例如，用于管理连接池的Bean的连接数量或池的大小限制。

**bean定义属性表**

| 属性                 | 解释在…                                                |
| :----------------------- | :----------------------------------------------------------- |
| Class (类)                    | [Instantiating Beans](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-class) |
| Name (名称)                    | [Naming Beans](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-beanname) |
| Scope (作用域)                   | [Bean Scopes](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes) |
| Constructor arguments (构造器参数)    | [Dependency Injection](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-collaborators) |
| Properties (属性)               | [Dependency Injection](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-collaborators) |
| Autowiring mode (自动装配模式)          | [Autowiring Collaborators](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-autowire) |
| Lazy initialization mode (延时初始化模式) | [Lazy-initialized Beans](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-lazy-init) |
| Initialization method (初始化方法)   | [Initialization Callbacks](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean) |
| Destruction method (销毁方法)       | [Destruction Callbacks](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean) |

##### 1.3.1 bean命名
	每个bean都有一个或多个标识符。 这些标识符在托管bean的容器内必须是唯一的。 一个bean通常只有一个标识符，但是如果它需要多个标识符，额外的标识符可以被认为是别名。
##### 1.3.2 bean实例化
	bean定义本质上是创建一个或多个对象的方法。 容器在需要时查看命名bean的方法，并使用由该bean定义封装的配置元数据来创建（或获取）实际对象。

#### 1.4 依赖关系
	典型的企业应用程序不是由单个对象（或者用Spring的说法是bean）组成的。
	即使是最简单的应用程序也有一些对象协同工作，以呈现最终用户所认为的一致应用程序。

##### 1.4.1 依赖注入
	依赖注入（DI）是一个过程，
	通过该过程，对象只通过构造函数参数、工厂方法的参数或在对象实例构造或从工厂方法返回后在对象实例上设置的属性来定义其依赖项（即，它们与之一起工作的其他对象）。
	然后容器在创建bean时注入这些依赖项。
	这个过程基本上是bean本身的逆过程（因此称为控制反转），它通过直接构造类或服务定位器模式来控制依赖项的实例化或位置。
	
	使用DI原则，代码更简洁，当对象与其依赖项一起提供时，去耦合更有效。对象不查找其依赖项，并且不知道依赖项的位置或类。

##### 1.4.2 依赖关系和配置细节
##### 1.4.3 depends-on 使用
	如果一个bean是另一个bean的依赖项，那通常意味着一个bean被设置为另一个bean的属性。
	通常，您可以使用基于XML的配置元数据中的<ref/>元素来实现这一点。
	但是，有时bean之间的依赖关系不那么直接。
	例如，需要触发类中的静态初始值设定项，例如数据库驱动程序注册。依赖属性可以显式地强制一个或多个bean在初始化使用此元素的bean之前初始化。
	以下示例使用depends-on属性来表示对单个bean的依赖：
	```xml
	<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
	<bean id="manager" class="ManagerBean" />
	```
	要表达对多个bean的依赖关系，请提供一个bean名称列表作为depends-on属性的值（逗号、空格和分号是有效的分隔符）：
	```xml
	<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
	    <property name="manager" ref="manager" />
	</bean>
	
	<bean id="manager" class="ManagerBean" />
	<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
	```

##### 1.4.4 延时初始化Beans
	一个延迟初始化的bean告诉IoC容器在该bean第一次被请求时而不是在启动时创建一个bean实例。
	```xml
	<beans default-lazy-init="true">
	    <!-- 配置在这里的bean不会被预先初始化... -->
	</beans>
	```

##### 1.4.5 自动装配协作器


###### 自动注入模式
| 模式          | 解释                                                  |
| :------------ | :----------------------------------------------------------- |
| `no` <br>不自动注入         | (默认模式) 不自动注入。Bean引用必须由“ref”元素定义。对于大型部署,不建议修改该默认配置, 因为显式地指定协作器可以提供更好的控制力和清晰度。 |
| `byName` <br>按名字注入     | Autowiring by property name. Spring looks for a bean with the same name as the property that needs to be autowired. For example, if a bean definition is set to autowire by name and it contains a `master` property (that is, it has a `setMaster(..)` method), Spring looks for a bean definition named `master` and uses it to set the property. |
| `byType` <br>按类型注入     | Lets a property be autowired if exactly one bean of the property type exists in the container. If more than one exists, a fatal exception is thrown, which indicates that you may not use `byType` autowiring for that bean. If there are no matching beans, nothing happens (the property is not set). |
| `constructor` <br>构造器注入 | Analogous to `byType` but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised. |

##### 1.4.6 方法注入
	在大多数应用场景中，容器中的大部分bean都是单例。 
	当单例bean需要与另一个单例bean协作，或者非单例bean需要与另一个非单例bean协作时，通常通过将一个bean定义为另一个bean的属性来处理依赖。 
	当bean生命周期不同时会出现问题。 假设单例bean A需要使用非单例（原型）bean B，可能在A上的每个方法调用上。容器只创建一次单例bean A，因此只有一次机会来设置属性。 每次需要时，容器都不能向bean A提供bean B的新实例。
	解决方案是放弃一些控制反转。 您可以通过实现ApplicationContextAware接口来让bean A知道容器，并且每当bean A需要时，通过对容器的getBean（“B”）调用请求（通常是新的）bean B实例。 

以下是这种方法的一个例子：
```java
// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean("command", Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
```
上面的做法是不可取的，因为业务代码与Spring框架耦合到了一起。 
方法注入是Spring IoC容器的一个高级特性，它允许以干净的方式处理这个用例。
```java
package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup("myCommand")
    protected abstract Command createCommand();
}
```

#### 1.5 Bean作用域

| 作用域                                                       | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [singleton](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton) <br>单例 | （默认作用域）将单个bean定义的范围限定为每个Spring IoC容器的单个对象实例。 |
| [prototype](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-prototype) <br>原型 | 将单个bean定义的范围限定为任意数量的对象实例。               |
| [request](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-request) <br>请求 | 将单个bean定义限定为单个HTTP请求的生命周期。也就是说，每个HTTP请求都有一个在单个bean定义后面创建的bean实例。仅在支持web的Spring“ApplicationContext”的上下文中有效。 |
| [session](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-session) <br>会话 | 将单个bean定义的范围限定为HTTP“Session”的生命周期。仅在支持web的Spring“ApplicationContext”的上下文中有效。 |
| [application](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-application) <br>应用 | 将单个bean定义限定为“ServletContext”的生命周期。仅在支持web的Spring“ApplicationContext”的上下文中有效。 |
| [websocket](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/web.html#websocket-stomp-websocket-scope) <br>双向通信 | 将单个bean定义限定为“WebSocket”的生命周期。仅在支持web的Spring“ApplicationContext”的上下文中有效。 |

##### 自定义作用域
	bean作用域机制是可扩展的。您可以定义自己的作用域，甚至可以重新定义现有的作用域，尽管后者被认为是不好的做法，并且您不能重写内置的singleton和prototype作用域。
	要将自定义作用域集成到Spring容器中，需要实现org.springframework.beans.factory.config.Scope接口。

#### 1.6 自定义Bean
	Spring框架提供了许多可以用来定制bean性质的接口。
	本节将其分组如下：
	- Lifecycle Callbacks
	- ApplicationContextAware and BeanNameAware
	- Other Aware Interfaces


#### 1.7 Bean定义继承

#### 1.8 容器集成拓展

#### 1.9 基于注解的容器配置

#### 1.10 类路径扫描和组件管理

#### 1.11 使用 JSR 330 标准注解

#### 1.12 基于Java的容器配置

#### 1.13 抽象环境

#### 1.14 注册代码织入

#### 1.15 ApplicationContext的其他功能
##### 1.15.1 使用MessageSource进行国际化(i18n)
##### 1.15.2 标准事件与自定义事件
	ApplicationContext中的事件处理通过ApplicationEvent类和ApplicationListener接口提供。

Spring提供了以下标准事件：

| 事件                  | 解释                                                         |
| --------------------- | ------------------------------------------------------------ |
| ContextRefreshedEvent | 例如，使用`ConfigurableApplicationContext`接口上的`refresh()`方法初始化或刷新`ApplicationContext`时发布。 这里的“初始化”意味着所有的Bean都被加载，检测并激活后处理器Bean，单例被预先实例化，并且`ApplicationContext`对象已准备好使用。 只要上下文没有关闭，只要所选的`ApplicationContext`实际上支持这种“热”刷新，就可以多次触发刷新。 例如，`XmlWebApplicationContext`支持热刷新，但`GenericApplicationContext`不支持。 |
| ContextStartedEvent   | 在`ApplicationContext`启动时发布，在`ConfigurableApplicationContext`接口上使用`start()`方法。 这里的“开始”意味着所有生命周期bean都会收到明确的启动信号。 通常，此信号用于在显式停止后重新启动Bean，但它也可用于启动尚未配置为自动启动的组件，例如尚未启动初始化的组件。 |
| ContextStoppedEvent   | 在`ApplicationContext`停止时发布，在`ConfigurableApplicationContext`接口上使用`stop()`方法。 这里“停止”意味着所有生命周期bean都会收到明确的停止信号。 停止的上下文可以通过start（）调用重新启动。 |
| ContextClosedEvent    | 在`ApplicationContext`关闭时发布，在`ConfigurableApplicationContext`接口上使用`close()`方法。 这里的“关闭”意味着所有的单身豆被销毁。 封闭的环境达到其生命的尽头; 它不能被刷新或重新启动。 |
| RequestHandledEvent   | 一个特定于web的事件，告知所有bean HTTP请求已被服务。 此事件在请求完成后发布。 该事件仅适用于使用Spring的DispatcherServlet的Web应用程序。 |



#### 1.16 Bean工厂
##### 1.16.1. BeanFactory or ApplicationContext?
	除非你有充分的理由，否则使用ApplicationContext。
	因为ApplicationContext包含了BeanFactory的所有功能，所以通常不推荐使用BeanFactory，除了少数情况，例如在资源受限的设备上运行的嵌入式应用程序中。
**BeanFactory与ApplicationContext的特性对比矩阵**
| 特性                   | `BeanFactory` | `ApplicationContext` |
| :------------------------------------------------------ | :------------ | :------------------- |
| Bean instantiation/wiring <br> Bean 实例化/连接                              | √           | √                  |
| Integrated lifecycle management  <br>  集成生命周期管理                     | ×            | √                  |
| Automatic `BeanPostProcessor` registration  <br>  自动`BeanPostProcessor`注册          | ×            | √                  |
| Automatic `BeanFactoryPostProcessor` registration <br> 自动`BeanFactoryPostProcessor`注册     | ×            | √                  |
| Convenient `MessageSource` access (for internalization)<br> 方便的`MessageSource`处理(对内的) | ×            | √                  |
| Built-in `ApplicationEvent` publication mechanism <br> 内置`ApplicationEvent`发布机制     | ×            | √                  |

### 2. 资源 （Resources）




### 3. 验证，数据绑定和类型转换 （Validation, Data Binding, and Type Conversion）


### 4. Spring表达式语言（SpEL）


### 5. Spring面向切面编程 （Aspect Oriented Programming with Spring）


### 6. Spring AOP APIs


### 7. Null-safety


### 8. 数据缓冲区和编解码器 （Data Buffers and Codecs）


### 9. 附录 （Appendix）

