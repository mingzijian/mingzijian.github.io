

Spring Core Technologies
----------------------------------------

## Spring 核心技术
 - IoC 容器 （The IoC Container）
 - 资源 （Resources）
 - 验证，数据绑定和类型转换 （Validation, Data Binding, and Type Conversion）
 - Spring表达式语言（SpEL）
 - Spring面向切面编程 （Aspect Oriented Programming with Spring）
 - Spring AOP APIs
 - Null-safety
 - 数据缓冲区和编解码器 （Data Buffers and Codecs）
 - 附录 （Appendix）

### 1. IoC 容器 （The IoC Container）
	介绍Spring的IoC容器
#### 1.1 IoC容器 和 beans 简介
	本章介绍Spring Framework实现控制反转（IoC）[1]原理。 IoC也被称为依赖注入（DI）。 
	它是一个过程，对象通过构造函数参数，工厂方法的参数或在工厂方法构造或返回后在对象实例上设置的属性来定义它们的依赖关系，即它们使用的其他对象。 
	容器在创建bean时会注入这些依赖关系。 
	这个过程从根本上来说是相反的，因此名为控制反转（IoC），bean本身通过使用类的直接构造或诸如Service Locator模式之类的机制来控制其依赖关系的实例化或位置。
	
	org.springframework.beans和org.springframework.context包是Spring Framework的IoC容器的基础。 
	BeanFactory接口提供了一种能够管理任何类型对象的高级配置机制。 ApplicationContext是BeanFactory的一个子接口。 
	它增加了与Spring的AOP功能更容易的集成; 消息资源处理（用于国际化），事件发布; 以及Web应用程序上下文（如Web应用程序上下文）以用于Web应用程序。
	
	简而言之，BeanFactory提供了配置框架和基本功能，而ApplicationContext添加了更多的企业特定功能。 
	ApplicationContext是BeanFactory的一个完整的超集，在本章中专门用于描述Spring的IoC容器。 
	有关使用BeanFactory而不是ApplicationContext的更多信息，请参阅BeanFactory。
	
	在Spring中，构成应用程序主干和由Spring IoC容器管理的对象称为bean。 
	bean是一个由 Spring IoC 容器去实例化、组装和管理的对象。 
	否则，bean只是应用程序中众多对象中的一个。 Bean和它们之间的依赖关系反映在容器使用的配置元数据中。

#### 1.2 容器概述
	`org.springframework.context.ApplicationContext`接口代表Spring IoC容器，负责实例化、配置和组装bean。
	容器通过读取元数据配置获取有关实例化、配置和组装哪些对象的指令。元数据配置可以使用用XML、Java注释或Java代码表示。
	它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。
	Spring提供了`ApplicationContext`接口的几个实现。
	在独立应用程序中，通常会创建`ClassPathXmlApplicationContext`或`FileSystemXmlApplicationContext`的实例。
	虽然XML是定义元数据配置的传统格式，但是您可以通过提供少量的XML配置来指示容器使用Java注释或代码作为元数据格式，以声明方式启用对这些附加元数据格式的支持。
	在大多数应用程序场景中，不需要显式用户代码来实例化Spring IoC容器的一个或多个实例。例如，在web应用程序场景中，在`web.xml`文件应用程序的文件通常就足够了（请参阅Web应用程序的便捷应用程序上下文实例化）。如果您使用Eclipse的Spring工具（一个Eclipse驱动的开发环境），只需单击几次鼠标或击键，就可以轻松地创建这个样板配置。
	
	下图显示了Spring如何工作的高级视图。应用程序类与配置元数据相结合，这样，在创建和初始化ApplicationContext之后，您就拥有了一个完全配置并可执行的系统或应用程序。

![The Spring IoC container](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/images/container-magic.png "The Spring IoC container.png")

#### 1.3 Bean概述

#### 1.4 依赖关系
	典型的企业应用程序不是由单个对象（或者用Spring的说法是bean）组成的。
	即使是最简单的应用程序也有一些对象协同工作，以呈现最终用户所认为的一致应用程序。

##### 1.4.1 依赖注入
	依赖注入（DI）是一个过程，
	通过该过程，对象只通过构造函数参数、工厂方法的参数或在对象实例构造或从工厂方法返回后在对象实例上设置的属性来定义其依赖项（即，它们与之一起工作的其他对象）。
	然后容器在创建bean时注入这些依赖项。
	这个过程基本上是bean本身的逆过程（因此称为控制反转），它通过直接构造类或服务定位器模式来控制依赖项的实例化或位置。
	
	使用DI原则，代码更简洁，当对象与其依赖项一起提供时，去耦合更有效。对象不查找其依赖项，并且不知道依赖项的位置或类。

##### 1.4.2 依赖关系和配置细节
##### 1.4.3 depends-on 使用
	如果一个bean是另一个bean的依赖项，那通常意味着一个bean被设置为另一个bean的属性。
	通常，您可以使用基于XML的配置元数据中的<ref/>元素来实现这一点。
	但是，有时bean之间的依赖关系不那么直接。
	例如，需要触发类中的静态初始值设定项，例如数据库驱动程序注册。依赖属性可以显式地强制一个或多个bean在初始化使用此元素的bean之前初始化。
	以下示例使用depends-on属性来表示对单个bean的依赖：
	```xml
	<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
	<bean id="manager" class="ManagerBean" />
	```
	要表达对多个bean的依赖关系，请提供一个bean名称列表作为depends-on属性的值（逗号、空格和分号是有效的分隔符）：
	```xml
	<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
	    <property name="manager" ref="manager" />
	</bean>
	
	<bean id="manager" class="ManagerBean" />
	<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
	```

##### 1.4.4 延时初始化Beans
	一个延迟初始化的bean告诉IoC容器在该bean第一次被请求时而不是在启动时创建一个bean实例。
	```xml
	<beans default-lazy-init="true">
	    <!-- 配置在这里的bean不会被预先初始化... -->
	</beans>
	```

##### 1.4.5 自动装配协作器


###### 自动注入模式
| 模式          | 解释                                                  |
| :------------ | :----------------------------------------------------------- |
| `no` <br>不自动注入         | (默认模式) 不自动注入。Bean引用必须由“ref”元素定义。对于大型部署,不建议修改该默认配置, 因为显式地指定协作器可以提供更好的控制力和清晰度。 |
| `byName` <br>按名字注入     | Autowiring by property name. Spring looks for a bean with the same name as the property that needs to be autowired. For example, if a bean definition is set to autowire by name and it contains a `master` property (that is, it has a `setMaster(..)` method), Spring looks for a bean definition named `master` and uses it to set the property. |
| `byType` <br>按类型注入     | Lets a property be autowired if exactly one bean of the property type exists in the container. If more than one exists, a fatal exception is thrown, which indicates that you may not use `byType` autowiring for that bean. If there are no matching beans, nothing happens (the property is not set). |
| `constructor` <br>构造器注入 | Analogous to `byType` but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised. |


##### 1.4.6 方法注入

#### 1.5 Bean作用域

| 作用域                                                       | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [singleton](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton) <br>单例 | （默认作用域）将单个bean定义的范围限定为每个Spring IoC容器的单个对象实例。 |
| [prototype](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-prototype) <br>原型 | 将单个bean定义的范围限定为任意数量的对象实例。               |
| [request](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-request) <br>请求 | 将单个bean定义限定为单个HTTP请求的生命周期。也就是说，每个HTTP请求都有一个在单个bean定义后面创建的bean实例。仅在支持web的Spring“ApplicationContext”的上下文中有效。 |
| [session](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-session) <br>会话 | 将单个bean定义的范围限定为HTTP“Session”的生命周期。仅在支持web的Spring“ApplicationContext”的上下文中有效。 |
| [application](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-application) <br>应用 | 将单个bean定义限定为“ServletContext”的生命周期。仅在支持web的Spring“ApplicationContext”的上下文中有效。 |
| [websocket](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/web.html#websocket-stomp-websocket-scope) <br>双向通信 | 将单个bean定义限定为“WebSocket”的生命周期。仅在支持web的Spring“ApplicationContext”的上下文中有效。 |

##### 自定义作用域
	bean作用域机制是可扩展的。您可以定义自己的作用域，甚至可以重新定义现有的作用域，尽管后者被认为是不好的做法，并且您不能重写内置的singleton和prototype作用域。
	要将自定义作用域集成到Spring容器中，需要实现org.springframework.beans.factory.config.Scope接口。

#### 1.6 自定义Bean

#### 1.7 Bean定义继承

#### 1.8 容器集成拓展

#### 1.9 基于注解的容器配置

#### 1.10 类路径扫描和组件管理

#### 1.11 使用 JSR 330 标准注解

#### 1.12 基于Java的容器配置

#### 1.13 抽象环境

#### 1.14 注册代码织入

#### 1.15 ApplicationContext的其他功能

#### 1.16 Bean工厂

### 2. 资源 （Resources）


### 3. 验证，数据绑定和类型转换 （Validation, Data Binding, and Type Conversion）


### 4. Spring表达式语言（SpEL）


### 5. Spring面向切面编程 （Aspect Oriented Programming with Spring）


### 6. Spring AOP APIs


### 7. Null-safety


### 8. 数据缓冲区和编解码器 （Data Buffers and Codecs）


### 9. 附录 （Appendix）

