[TOC]

MySQL 锁
---------------

## MySQL 有哪些锁

### 按锁的粒度分

行锁 & 页锁 & 表锁 & 全局锁

#### 行锁（Row Locks）

- **介绍**：行锁是锁机制中粒度最细的一种，它只锁定数据表中的单个行记录。
- **存储引擎**：InnoDB存储引擎支持行锁。
- **优点**：行锁提供了较高的并发性，因为其他行的锁定不会影响当前行的锁定状态。
- **兼容性**：行锁允许其他事务读取或写入其他未锁定的行。

#### 页锁（Page Locks）

- **介绍**：页锁是介于行锁和表锁之间的一种锁机制，它锁定的是数据表的一个页面（page），通常包含多个行记录。
- **存储引擎**：使用页级锁定的主要是BerkeleyDB存储引擎，已经被InnoDB取代，因此页锁在MySQL中使用较少。
- **优点**：页锁的开销和加锁速度介于表锁和行锁之间，提供了一定程度的并发性。
- **缺点**：页锁可能导致一定程度的锁冲突，因为它锁定的是一组数据而不是单个数据项。

#### 表锁（Table Locks）

- **介绍**：锁定整个数据表。
- **存储引擎**：MyISAM存储引擎只支持表锁。
- **优点**：表锁的开销小，加锁速度快。
- **缺点**：表锁的锁粒度大，可能导致较高的锁冲突概率，降低了并发性能。在读操作多于写操作的场景下，表锁可能会成为性能瓶颈。

#### 全局锁（全部表只读）

MySQL中的全局锁是一种特殊的锁，它锁定整个数据库实例，而不仅仅是单个表或行。

全局锁通常用于需要对整个数据库进行一致性读取的场景，例如进行数据库备份。

##### 使用场景

1. **全库逻辑备份**：全局锁最典型的使用场景是在执行全库逻辑备份时，如使用`mysqldump`工具进行备份。通过全局锁，可以确保在备份期间数据库的数据保持不变，从而获得数据库的一致性视图。
2. **防止数据不一致**：在备份过程中，如果没有全局锁，数据库中的数据可能会因为并发的更新操作而发生变化，导致备份数据与数据库当前状态不一致。

##### 语法

- **加全局读锁**：

  ```sql
  FLUSH TABLES WITH READ LOCK;
  ```

  这个命令会锁定所有表，使得它们只能被读取，不能被修改。

- **释放全局锁**：

  ```sql
  UNLOCK TABLES;
  ```

  这个命令会释放之前通过`FLUSH TABLES WITH READ LOCK`设置的全局锁。

##### 特点

- **只读状态**：全局锁会将整个数据库置于只读状态，所有数据修改操作（如INSERT、UPDATE、DELETE）和数据定义操作（如ALTER TABLE）都会被阻塞。
- **影响业务**：在主库上使用全局锁进行备份时，所有写操作都会被暂停，这可能会影响业务的正常运行。在从库上使用全局锁时，可能会导致主从同步延迟。
- **风险**：全局锁是一个重量级锁，使用不当可能会导致长时间锁等待，甚至整个数据库的访问阻塞。
- **与其他锁的关系**：全局锁与表锁和行锁是不同层次的锁，它的作用范围更广，影响整个数据库实例。

##### 注意事项

- 在使用全局锁时，应确保数据库处于空闲状态，或者在业务低峰期进行，以减少对业务的影响。
- 对于支持事务的存储引擎（如InnoDB），可以使用`mysqldump`的`--single-transaction`参数来避免使用全局锁，从而在单个事务中获取一致性视图进行备份。
- 全局锁的使用应该谨慎，因为它可能会对数据库性能和可用性产生重大影响。



### 按锁的力度分

#### 共享锁和独占锁

`InnoDB`实现标准行级锁定，其中有两种类型的锁： [共享 ( `S`) 锁](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_shared_lock)和[排它 ( `X`) 锁](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_exclusive_lock)。

- [共享( `S`) 锁](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_shared_lock)允许持有该锁的事务读取一行。可能存在其他事务也需要读，所以不能做修改。
- [独占( `X`) 锁](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_exclusive_lock)允许持有该锁的事务更新或删除行。自己独占的，想怎么玩都行。



### 按锁的时机分

乐观锁 & 悲观锁



 - 死锁
 - 间隙锁
 - 行锁 & 页锁 & 表锁 & 全局锁
 - 乐观锁 & 悲观锁
 - 共享锁 & 排它锁(独占锁)

### 死锁

多个进行相互等待对方资源，在得到所有资源继续运行之前，都不会释放自己已有的资源，这样造成了循环等待的现象，称为死锁。


#### 死锁产生

##### 条件:

1. 资源互斥
2. 占有和等待
3. 资源不可剥夺
4. 环路等待

##### 示例:

1, [17:00:47] sessionA 获取 t2成功

2, [17:00:49] sessionB 获取t1成功

3, [17:00:57] sessionA 获取t1等待(死锁)

4, [17:00:59] sessionB 获取t2成功



```sql
-- sessionA
start transaction ;

update t2 set age = 1 where id = 1;
select sleep(10);
update t1 set age = 2 where id = 1;

commit ;

-- sessionB
start transaction ;

update t1 set age = 1 where id = 1;
select sleep(10);
update t2 set age = 2 where id = 1;

commit ;
```

#### 死锁影响



#### 死锁检测



#### 死锁恢复



#### 死锁避免



### 意向锁（intention-locks）

`InnoDB`支持*多粒度锁定*，允许行锁和表锁共存。

意向锁的主要目的是表明有人正在锁定一行，或者将要锁定表中的一行。（有执行锁的意向）

意向锁不会阻止除全表请求之外的任何内容（例如，[`LOCK TABLES ... WRITE`](https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html)）。

如果请求事务与现有锁兼容，则将锁授予该事务，反之则不会授予该锁。事务会等待，直到释放冲突的现有锁。

如果锁请求与现有锁冲突并且由于会导致 [死锁](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_deadlock)而无法被授予，则会发生错误。

表级锁类型兼容性总结：

| 锁   | `X`  | `IX` | `S`  | `IS` |
| :--- | :--- | :--- | :--- | ---- |
| `X`  | 冲突 | 冲突 | 冲突 | 冲突 |
| `IX` | 冲突 | 兼容 | 冲突 | 兼容 |
| `S`  | 冲突 | 冲突 | 兼容 | 兼容 |
| `IS` | 冲突 | 兼容 | 兼容 | 兼容 |

意向锁定协议如下：（上锁之前必须先表明意向）（双方都只表明意向是兼容的）

- 在事务可以获取表中行的共享锁之前，它必须首先获取`IS`表上的锁或更强的锁。
- 在事务可以获取表中行的排他锁之前，它必须首先获取`IX` 表上的锁。



### 记录锁（Record Locks）

记录锁是索引记录上的锁。

例如， `SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;` 防止任何其他事务插入、更新或删除 值为 的`t.c1`行 `10`。

记录锁始终锁定索引记录，即使表定义为没有索引。

### 间隙锁 （Gap Locks）

在MySQL中，间隙锁（Gap Locks）是InnoDB存储引擎特有的一种锁机制，用于防止幻读（Phantom Reads）。

间隙锁锁定的是两个索引记录之间的间隙，但不包括这些记录本身。

这种锁的存在是为了维护可重复读（REPEATABLE READ）隔离级别下的一致性。

例如，`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;`防止其他事务将值插入`15`到 `t.c1`列 中，无论该列中是否已经存在任何此类值，因为该范围内的所有现有值之间的间隙已被锁定。

间隙可能跨越单个索引值、多个索引值，甚至是空的。

间隙锁是性能和并发性之间权衡的一部分，并且在某些事务隔离级别中使用，而在其他事务隔离级别中则不使用。

间隙锁定可以显式禁用。如果您将事务隔离级别更改为 [`READ COMMITTED`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-committed)或启用 [`innodb_locks_unsafe_for_binlog`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_locks_unsafe_for_binlog) 系统变量（现已弃用），则会发生这种情况。在这种情况下，间隙锁定对搜索和索引扫描禁用，并且仅用于外键约束检查和重复键检查。

对于使用唯一索引锁定行来搜索唯一行的语句，不需要间隙锁定。 

如果`id`未建立索引或具有非唯一索引，则该语句会锁定前面的间隙。

### 临键锁（Next-Key Locks）

临键锁是索引记录上的记录锁和索引记录之前的间隙上的间隙锁的组合。

临键锁 = 记录锁 + 间隙锁

### 参考
 - https://juejin.im/post/5b55b842f265da0f9e589e79
 - https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html